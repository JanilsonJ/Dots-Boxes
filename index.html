<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pontinhos — placar final + sem scroll</title>
    <style>
        :root { --cell: 36px; --g: 10px; --edge-thick: 12px; --dot: 10px; }
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            height: 100dvh; margin: 0; background: #0f172a; color: #e5e7eb;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            display: grid; grid-template-rows: auto 1fr; overflow: hidden; /* sem scroll */
        }
        header { padding: 12px 16px; display:flex; gap:12px; flex-wrap:wrap; align-items:center; background:#111827; border-bottom:1px solid #1f2937; }
        header h1 { margin:0; font-size: 16px; font-weight: 700; letter-spacing:.2px; }
        .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
        .controls label { background:#0b1220; border:1px solid #1f2937; padding:6px 8px; border-radius:10px; display:flex; gap:8px; align-items:center; }
        .controls input[type=number] { width:70px; padding:6px 8px; border-radius:8px; border:1px solid #334155; background:#0b1220; color:#e5e7eb; }
        .btn { padding:8px 12px; border-radius:10px; border:1px solid #334155; background:#0b1220; color:#e5e7eb; cursor:pointer; }
        .btn:hover { filter: brightness(1.08); }

        main {
            display:grid; grid-template-columns: 1fr 320px; gap:12px; padding:12px;
            overflow: hidden; /* sem scroll global; painéis rolam por dentro se precisar */
        }

        .panel { background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:10px; min-height:0; }
        .mainPanel { display:flex; flex-direction:column; min-height:0; }
        .status { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
        .badge { padding:6px 10px; border-radius:999px; font-weight:700; border:1px solid #1f2937; display:inline-flex; gap:8px; align-items:center; }
        .dot-c { width:10px; height:10px; border-radius:50%; display:inline-block; }
        .p1c { background:#3b82f6; } .p2c { background:#ef4444; }

        #boardWrapper { margin-top:8px; flex:1; width:100%; height:100%; display:grid; place-items:center; min-height:0; }
        #board {
            display:grid; gap: var(--g);
            grid-template-columns: repeat(5, var(--cell));
            grid-template-rows: repeat(5, var(--cell));
            align-items:center; justify-items:center;
            max-width:100%; max-height:100%;
        }

        .dot  { width: var(--dot); height: var(--dot); background:#e5e7eb; border-radius:50%; }
        .edge { all: unset; cursor:pointer; background:#1f2937; border-radius:999px; transition: transform .06s ease, box-shadow .06s ease, background .1s ease; }
        .edge:focus-visible { outline: 2px solid #f59e0b; outline-offset: 2px; }
        .edge.h { width: 100%; height: var(--edge-thick); }
        .edge.v { height: 100%; width: var(--edge-thick); }
        .edge:hover { box-shadow: 0 0 0 2px #334155 inset; }
        .edge.p1 { background:#3b82f6; } .edge.p2 { background:#ef4444; }
        .edge[disabled] { cursor: default; box-shadow:none; }

        .box { width:100%; height:100%; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:14px; color:#e5e7eb; user-select:none; }
        .box.p1 { background: rgba(59,130,246,.35); }
        .box.p2 { background: rgba(239,68,68,.35); }

        .hist { display:flex; flex-direction:column; min-height:0; }
        .hist h3 { margin: 0 0 8px 0; font-size: 14px; letter-spacing:.2px; color:#cbd5e1;}
        .hist ol { margin:0; padding-left: 16px; overflow:auto; flex:1; display:flex; flex-direction:column-reverse; }
        .hist li { padding:6px 0; border-bottom:1px dashed #1f2937; color:#cbd5e1; }

        footer { text-align:center; font-size:12px; color:#94a3b8; padding:8px 0 10px; }
        @media (max-width: 860px){ main { grid-template-columns: 1fr 280px; } }
    </style>
</head>
<body>
<header>
    <h1>Pontinhos</h1>
    <div class="controls">
        <label>Linhas <input id="rowsInput" type="number" min="1" max="15" value="4" /></label>
        <label>Colunas <input id="colsInput" type="number" min="1" max="15" value="4" /></label>
        <button id="newGameBtn" class="btn">Nova partida</button>
        <button id="clearHistBtn" class="btn" title="Limpa o histórico de placares">Limpar histórico</button>
    </div>
</header>

<main>
    <section class="panel mainPanel">
        <div class="status" id="statusBar">
            <span class="badge"><span class="dot-c p1c"></span> J1: <strong id="score1">0</strong></span>
            <span class="badge"><span class="dot-c p2c"></span> J2: <strong id="score2">0</strong></span>
            <span class="badge">Vez: <strong id="turnLabel">Jogador 1</strong></span>
            <span class="badge">Tabuleiro: <strong id="sizeLabel">4 × 4</strong></span>
        </div>
        <div id="boardWrapper">
            <div id="board" aria-label="Tabuleiro do jogo dos pontinhos"></div>
        </div>
        <footer>Regra: fez caixa, joga de novo. Vence quem conquistar mais caixas.</footer>
    </section>

    <aside class="panel hist">
        <h3>Histórico (placar final)</h3>
        <ol id="history"></ol>
    </aside>
</main>

<script>
    (() => {
        const els = {
            board: document.getElementById('board'),
            wrapper: document.getElementById('boardWrapper'),
            score1: document.getElementById('score1'),
            score2: document.getElementById('score2'),
            turnLabel: document.getElementById('turnLabel'),
            sizeLabel: document.getElementById('sizeLabel'),
            rowsInput: document.getElementById('rowsInput'),
            colsInput: document.getElementById('colsInput'),
            newGameBtn: document.getElementById('newGameBtn'),
            clearHistBtn: document.getElementById('clearHistBtn'),
            history: document.getElementById('history'),
        };

        const STATE = {
            rows: 4, cols: 4, gap: 10,
            H: [], V: [], B: [],
            boxesEls: [],
            current: 1,
            score: [0, 0],
            totalBoxes: 0,
            ended: false,
        };

        function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

        function initArrays(r, c) {
            STATE.rows = r; STATE.cols = c;
            STATE.totalBoxes = r * c;
            STATE.H = Array.from({length: r + 1}, () => Array(c).fill(0));
            STATE.V = Array.from({length: r}, () => Array(c + 1).fill(0));
            STATE.B = Array.from({length: r}, () => Array(c).fill(0));
            STATE.boxesEls = Array.from({length: r}, () => Array(c).fill(null));
            STATE.current = 1;
            STATE.score = [0, 0];
            STATE.ended = false;
            updateHUD();
        }

        function updateHUD() {
            els.score1.textContent = STATE.score[0];
            els.score2.textContent = STATE.score[1];
            els.turnLabel.textContent = STATE.ended ? '—' : `Jogador ${STATE.current}`;
            els.sizeLabel.textContent = `${STATE.rows} × ${STATE.cols}`;
        }

        function gridTracks() {
            return { colsTracks: STATE.cols * 2 + 1, rowsTracks: STATE.rows * 2 + 1 };
        }

        function fitCellSize() {
            const { colsTracks, rowsTracks } = gridTracks();
            // espaço interno disponível
            const w = els.wrapper.clientWidth || 600;
            const h = els.wrapper.clientHeight || 600;
            const cellW = Math.floor((w - (colsTracks - 1) * STATE.gap) / colsTracks);
            const cellH = Math.floor((h - (rowsTracks - 1) * STATE.gap) / rowsTracks);
            const cell = Math.max(18, Math.min(cellW, cellH));
            const edge = Math.max(6, Math.round(cell / 3));
            const dot  = Math.max(6, Math.round(cell / 4));

            els.board.style.setProperty('--cell', `${cell}px`);
            els.board.style.setProperty('--g', `${STATE.gap}px`);
            els.board.style.setProperty('--edge-thick', `${edge}px`);
            els.board.style.setProperty('--dot', `${dot}px`);
        }

        function addFinalToHistory({r, c, s1, s2}) {
            const li = document.createElement('li');
            const now = new Date();
            const hh = String(now.getHours()).padStart(2,'0');
            const mm = String(now.getMinutes()).padStart(2,'0');
            const dd = String(now.getDate()).padStart(2,'0');
            const mo = String(now.getMonth()+1).padStart(2,'0');
            const yy = now.getFullYear();
            const winner = s1 === s2 ? 'Empate' : (s1 > s2 ? 'J1' : 'J2');
            li.textContent = `[${dd}/${mo}/${yy} ${hh}:${mm}] ${r}×${c} — ${s1}×${s2} (${winner})`;
            els.history.appendChild(li); // flex column-reverse -> novo aparece no topo
            // mantém no máx 200 partidas
            while (els.history.children.length > 200) els.history.removeChild(els.history.firstChild);
        }

        function buildBoard(r, c) {
            els.board.innerHTML = '';
            const { colsTracks, rowsTracks } = gridTracks();
            els.board.style.gridTemplateColumns = `repeat(${colsTracks}, var(--cell))`;
            els.board.style.gridTemplateRows = `repeat(${rowsTracks}, var(--cell))`;

            for (let R = 0; R < rowsTracks; R++) {
                for (let C = 0; C < colsTracks; C++) {
                    if (R % 2 === 0 && C % 2 === 0) {
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        els.board.appendChild(dot);
                    } else if (R % 2 === 0 && C % 2 === 1) {
                        const hr = R >> 1;
                        const hc = (C - 1) >> 1;
                        const btn = document.createElement('button');
                        btn.className = 'edge h';
                        btn.dataset.type = 'h';
                        btn.dataset.r = String(hr);
                        btn.dataset.c = String(hc);
                        btn.setAttribute('aria-label', `Aresta horizontal L${hr+1} C${hc+1}`);
                        els.board.appendChild(btn);
                    } else if (R % 2 === 1 && C % 2 === 0) {
                        const vr = (R - 1) >> 1;
                        const vc = C >> 1;
                        const btn = document.createElement('button');
                        btn.className = 'edge v';
                        btn.dataset.type = 'v';
                        btn.dataset.r = String(vr);
                        btn.dataset.c = String(vc);
                        btn.setAttribute('aria-label', `Aresta vertical L${vr+1} C${vc+1}`);
                        els.board.appendChild(btn);
                    } else {
                        const br = (R - 1) >> 1;
                        const bc = (C - 1) >> 1;
                        const box = document.createElement('div');
                        box.className = 'box';
                        box.dataset.box = `${br},${bc}`;
                        els.board.appendChild(box);
                        STATE.boxesEls[br][bc] = box;
                    }
                }
            }
            fitCellSize();
        }

        function isBoxComplete(br, bc) {
            return (
                STATE.H[br][bc] &&
                STATE.H[br + 1][bc] &&
                STATE.V[br][bc] &&
                STATE.V[br][bc + 1]
            );
        }

        function claimBox(br, bc, player) {
            if (STATE.B[br][bc]) return false;
            STATE.B[br][bc] = player;
            const el = STATE.boxesEls[br][bc];
            if (el) {
                el.classList.add(player === 1 ? 'p1' : 'p2');
                el.textContent = player === 1 ? '1' : '2';
            }
            STATE.score[player - 1]++;
            return true;
        }

        function checkEnd() {
            if (STATE.score[0] + STATE.score[1] >= STATE.totalBoxes) {
                STATE.ended = true;
                const [s1, s2] = STATE.score;
                addFinalToHistory({ r: STATE.rows, c: STATE.cols, s1, s2 });
                updateHUD();
                // desabilita any remaining edges (segurança)
                els.board.querySelectorAll('.edge:not([disabled])').forEach(b => b.disabled = true);
            }
        }

        function handleEdgeClick(target) {
            if (!target || !target.classList.contains('edge') || STATE.ended) return;
            if (target.disabled || target.dataset.owner) return;

            const type = target.dataset.type;
            const r = Number(target.dataset.r);
            const c = Number(target.dataset.c);
            const player = STATE.current;

            if (type === 'h') STATE.H[r][c] = player; else STATE.V[r][c] = player;
            target.dataset.owner = String(player);
            target.disabled = true;
            target.classList.add(player === 1 ? 'p1' : 'p2');

            let formed = 0;
            if (type === 'h') {
                if (r > 0 && isBoxComplete(r - 1, c)) formed += claimBox(r - 1, c, player) ? 1 : 0;
                if (r < STATE.rows && isBoxComplete(r, c)) formed += claimBox(r, c, player) ? 1 : 0;
            } else {
                if (c > 0 && isBoxComplete(r, c - 1)) formed += claimBox(r, c - 1, player) ? 1 : 0;
                if (c < STATE.cols && isBoxComplete(r, c)) formed += claimBox(r, c, player) ? 1 : 0;
            }

            if (!formed) STATE.current = STATE.current === 1 ? 2 : 1;

            updateHUD();
            checkEnd();
        }

        els.board.addEventListener('click', (ev) => {
            const btn = ev.target.closest('.edge');
            if (btn) handleEdgeClick(btn);
        });

        function newGame() {
            const r = clamp(parseInt(els.rowsInput.value, 10) || 4, 1, 15);
            const c = clamp(parseInt(els.colsInput.value, 10) || 4, 1, 15);
            initArrays(r, c);
            buildBoard(r, c);
        }

        els.newGameBtn.addEventListener('click', newGame);
        els.clearHistBtn.addEventListener('click', () => { els.history.innerHTML = ''; });

        // Reajuste dinâmico (sem scroll)
        window.addEventListener('resize', fitCellSize);
        // Observa mudanças no wrapper (melhor quando header quebra linha)
        new ResizeObserver(fitCellSize).observe(els.wrapper);

        // Inicializa
        newGame();
    })();
</script>
</body>
</html>
